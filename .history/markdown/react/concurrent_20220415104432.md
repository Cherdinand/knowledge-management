
### 新版context

_带consumer_

这种方式更好用，在需要用到context的组件外包一层consumer

``` js
// 默认值"fucking left"，当组件所处的tree中没有找到provider的时候这个默认值才会生效
const LeftContext = React.createContext("fucking left");

class Left extends React.Component {
  render() {
    return (
      <LeftContext.Consumer>
        {(value) => <div>{value}</div>}
      </LeftContext.Consumer>
    );
  }
}

export default function App() {
  return (
    // Provider只有一个value参数。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。
    <LeftContext.Provider value={"aaaa"}>
      <Left />
    </LeftContext.Provider>
  );
}
```

_不带consumer_

``` js
const LeftContext = React.createContext("fucking left");

class Block extends React.Component {
  render() {
    return <Left />;
  }
}

class Left extends React.Component {
  static contextType = LeftContext; // contextType属性能让组件使用 this.context 来消费最近 Context 上的那个值。

  render() {
    return <div>{this.context}</div>
  }
}

export default function App() {
  return (
    <LeftContext.Provider value={"aaaa"}>
      <Block />
    </LeftContext.Provider>
  );
}
```

export const ContextMeta = {
  anchors: [
    '新版context',
    '旧版context',
  ]
}