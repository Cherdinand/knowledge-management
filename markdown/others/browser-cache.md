### 缓存的一些基本设定

1、网页的入口html文件是不会被缓存的，只有静态资源的文件是会被缓存的。`但是在微信小程序中微信是会主动缓存html入口文件的，这里是一个坑。`

### Service Worker

Service Worker 实际上是在浏览器上开一个独立的线程，然后通过注册监听事件，监听并拦截浏览器上的请求事件，然后查询是否存在缓存。如果存在缓存则返回缓存，否则继续发送请求。

Service Worker特性：

1、Service worker 广泛使用了 promise。

2、Service worker 是一个可编程的网络代理，允许你去控制如何处理页面的网络请求。

3、Service worker 可以拦截和处理网络请求，包括以编程方式来管理`被缓存`的响应。一般可以用来实现缓存功能。

4、使用Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

5、Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

6、Service Worker 允许你提供离线体验，而且是开发人员完全可控的离线体验。

### 浏览器缓存流程

1、调用 Service Worker 的 fetch 事件响应

2、查看 memory cache

3、查看 disk cache。这里又细分：如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200；如果有强制缓存但已失效，使用协商缓存，比较后确定 304 还是 200

4、发送网络请求，等待网络响应

5、把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)

6、把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)

7、把响应内容存入 Service Worker 的 Cache Storage （如果 Service Worker 的脚本调用了 cache.put())

### 浏览器缓存机制

 ![浏览器缓存机制](LiuLanQiHuanCunJiZhi.png "600px") 

由上图我们可以看出，浏览器缓存机制的关键行为有两个：

1、浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
  
2、浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

`其中浏览器向浏览器缓存确认缓存有效性的行为即为强制缓存，而浏览器向服务器确认缓存有效性的行为则为协商缓存。`

### 强制缓存和协商缓存

_强制缓存_

强制缓存作用在浏览器缓存中，当我们向服务器请求一个资源的时候，浏览器的第一步就是去浏览器缓存中寻找是否有匹配的缓存。如果发现有匹配的缓存，那么就使用浏览器缓存，否则则向服务器发送请求（协商缓存）。

强制缓存使用到的两个header属性：

Expires: 一个向后兼容的遗留属性。HTTP1.0的内容，提供一个过期日期，过期缓存将被视为无效。如果 Cache-Control 中有 max-age 或 s-man-age 指令，浏览器将忽略此字段。优先级： s-man-age > man-age > Expires

Cache-Control: 控制缓存行为。

`常见的no-chche的意思是每次使用缓存的时候必须使用协商缓存的方式，也就是需要先向服务器确认缓存的有效性。`

 ![CacheControl值的行为](CacheControl.png "600px") 

`强制缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段。也就是说可能存在我们把时间设置为一年，然而我们在一年之内对这个资源进行过修改，这可能会导致加载文件不是服务器端最新的资源。为了解决这个更新的问题，我们可以在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。`

_协商缓存_

协商缓存是指当我们浏览器缓存失效或者说我们认为的要求浏览器在使用缓存的时候必须向服务器确认缓存有效性（cache-control：no-cache）的时候发生。

协商缓存使用到的两个header属性：

1、Last-Modified / If-Modified-Since: HTTP1.0的内容。上次修改缓存的日期和时间。

浏览器第一次请求接口的时候，若服务器返回了Last-Modified，则相关数据和Last-Modified等信息写入浏览器缓存。当浏览器下一次请求相同的接口的时候，发现了Last-Modified这个字段，那么浏览器就会在第二次请求的请求头增加If-Modified-Since字段，值为上次返回的Last-Modified的值，然后向服务器发送请求。

当服务器接收到If-Modified-Since之后，会向相关资源的Last-Modified的值进行比较。如果值相等，则一般（为什么是一般，下面再解释。）会认为是资源没有修改过，所以返回304的状态码，通知浏览器可以去浏览器缓存中拿之前的缓存用。假如浏览器这边的Last-Modified值大于If-Modified-Since的值，则说明在服务器这边资源有过更新，则返回200的状态码和新的资源。

上面为什么说是一般呢：

如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源

`因为 Last-Modified 只能以秒计时`，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

`可以看出，使用Last-Modified的方式是存在一些不足的。`

2、ETag / If-None-Match: 用作缓存验证标记的唯一字符串，是文件内容的hash值。只要hash值不相同，就认为缓存内容已改变，不能使用缓存。`只有当文件从缓存中过期时，ETag 才会用于请求。`

浏览器第一次请求接口的时候，若服务器返回了ETag，则相关数据和ETag等信息写入浏览器缓存。当浏览器下一次请求相同的接口的时候，发现了ETag这个字段，那么浏览器就会在第二次请求的请求头增加If-None-Match字段，值为上次返回的ETag的值，然后向服务器发送请求。

服务器拿到If-None-Match的值与相关资源的ETag的值进行比较。如果相同则返回304状态码，否则返回200状态码和新的资源。

由于ETag的唯一性，所以这个字段相对来说更加严谨，更加精确。`服务器校验优先考虑Etag。`

### 实际场景应用缓存策略

1、 频繁变动的资源 Cache-Control: no-cache

对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

2、 不常变化的资源 Cache-Control: max-age=31536000

通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。

### 用户行为对浏览器缓存的影响

所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：

1、打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。

2、普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。

3、强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。

### 参考资料

[很好的一篇专门介绍浏览器缓存的文章](https://blog.fundebug.com/2019/01/08/browser-cache-mechanism)

export const browserCacheMeta = {
  anchors: [
    '缓存的一些基本设定',
    'Service Worker',
    '浏览器缓存机制',
    '强制缓存和协商缓存',
    '实际场景应用缓存策略',
    '用户行为对浏览器缓存的影响',
    '参考资料',
  ]
}












