### 基本知识

Web诞生的初衷是为了全世界的学者们进行知识共享。

而为了让计算机和网络设备能够完成相互通信，就必须制定一套协议。比如ip地址的选定方法，寻找异地用户的方法，双方建立通信的顺序，以及web页面显示需要处理的步骤等等都需要有一套协议来统一。

而像这样把与互联网相关联的协议集合起来的总称即为`TCP/IP`。注意TCP/IP是一套协议的总称，而我们经常说的`HTTP（HyperText Transfer Protocol）超文本传输协议`则是其中的一个常用的协议。

我们习惯性地把TCP/IP协议群按层次分为五个层。应用层、传输层、网络层、链路层。每一层也是包含了一套协议。

```js
TCP/IP： {
  应用层： { // 决定了向用户提供应用服务时通信的活动，这是最接近用户的一层，因为这一层的协议规定的都是面对用户相关部分的协议。
    FTP(File Transfer Protocol 文件传输协议)
    DNS(Domain Name System 域名系统)  // 提供域名到IP地址之间的解析服务。即www.baidu.com ==> 192.168.1.1
    Http(HyperText Transfer Protocol 超文本传输协议) // 用于客户端和服务器端之间的通信，发送请求的一方为客户端，而接受请求并提供资源的一方为服务器端
    ...
  }
  传输层： { // 与应用层对接，提供处于网络连接中两台计算机之间的数据传输，针对于数据这一块。
    TCP(Transmission Control Protocol 传输控制协议) // 将大块数据分割成数据包（方便传输）并能够确认数据最终是否送达给对方。
    UDP(User Data Protocol 用户数据报协议)
    ...
  }
  网络层： { // 处理传输层提供的数据包，网络层的作用就是决定了与对方计算机之间通过多台计算机或网络设备进行传输时，在众多路线中选择一条传输路线。
    IP(Internet Protocol 网际协议) // 把各种数据包传输给对方。
    ...
  }
  链路层： { // 用来处理连接网络的硬件部分。硬件上的范畴均在链路层的作用范围之内。
    协议1
    协议2
    ...
  }
  物理层 // 用光缆、电缆、双绞线、无线电波等方式把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。
}
```

### URI与URL

URI(Universal Resource Identifier)统一资源标志符

URL(Universal Resource Locator) 统一资源定位符

统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。而URL就是以位置为规则把一个资源独一无二的标识出来。所以我们说URL是URI的一个子集。

拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。

那统一资源定位符URL是什么呢。

也拿人做例子然后跟HTTP的URL做类比，就可以有：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。

URL是以描述人的位置来唯一确定一个人的。在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：身份证号：123456789来标识他。

所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URI的一种实现，而URL就是用定位的方式实现的URI。

回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。

### HTTP 

HTTP的一大特点就是不保存状态。每一次的请求和响应都不做持久化处理，不保留之前一切的请求或响应报文的信息。这是为了更快的处理大量请求。而这一特点就会导致一个用户在浏览同一网站的不同页面的时候，网站并不能保持用户的登录状态。这也是之后发展出Cookie、session、token等技术的原因。

_HTTP状态码_

HTTP状态码的分类

| 分类	| 分类描述	|
| ------------ | ---- |
| 1**	| 信息，服务器收到请求，需要请求者继续执行操作 |
| 2**	| 成功，操作被成功接收并处理 |
| 3**	| 重定向，需要进一步的操作以完成请求 |
| 4**	| 客户端错误，请求包含语法错误或无法完成请求 |
| 5**	| 服务器错误，服务器在处理请求的过程中发生了错误 |

常见的HTTP状态码

| 状态码	| 状态码英文名称 | 中文描述 |  
| ----- | ----------- | ------- |
| 200	| OK |	请求已成功，请求所希望的响应头或数据体将随此响应返回。 |
| 304	| Not Modified | 未修改。服务器返回此状态码时，不会返回任何资源。所请求的资源未修改，可直接使用客户端未过期的缓存。 |
| 400	| Bad Request |	1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 |
| 401	| Unauthorized | 请求要求用户的身份认证 |
| 403	| Forbidden |	服务器理解客户端的请求，但是拒绝执行此请求 |
| 404	| Not Found |	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 500	| Internal Server Error |	服务器内部错误，无法完成请求 |
| 502	| Bad Gateway |	充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 |
| 503	| Service Unavailable |	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504	| Gateway Time-out |	充当网关或代理的服务器，未及时从远端服务器获取请求 |

### 代理和网关

_代理_

代理服务器的基本行为就是接收客户端发送的请求后转发给其它服务器。代理不改变请求URI，会直接发送给下一个代理服务器或持有资源的源服务器。代理就像是redux里面的中间件，可以有很多个代理服务器。

代理服务器存在的意义是我们可以在代理服务器中修改返回信息（比如数据的加密和解密）以及缓存。缓存代理会将首次的资源副本缓存在代理服务器上，当再次接收到对相同资源的请求时，就可以省去对源服务器的请求，直接将缓存的资源返回给客户端。

_网关_

网关的工作机制和代理非常相似。区别在于网关可以提供非HTTP的协议服务（`那什么是HTTP的协议服务？`）。 

广义上的网关实质上具有转换作用的处理不同协议间的交流的一个东西。

`而电脑网络中的网关通常是能够处理不同子网络通信的一个网络层的概念。只要连接两个不同的网络的设备都可以叫网关。网关可以在路由器上、可以在三层交换机上、可以在防火墙上、可以在服务器上，并不是一个物理的设备。`

`可以理解为网关是一个软件，而上面所说的路由器、三层交换机、防火墙、服务器等是硬件。软件必须安装在硬件上才能发挥作用，而硬件却不一定要安装这个软件。`

`通常我们普通家庭上网，我们的网络的网关会在家用路由器上，家用路由器的LAN接口的IP地址就是你所在局域网中的网关。`

比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。

在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。

`而要实现这两个网络之间的通信，则必须通过网关。`如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。

### HTTP 1.1首部字段

_报文和实体_

个人理解： 

报文分为请求报文和响应报文，报文是HTTP中的基本通信单位。客户端、代理服务器与源服务器之间都是通过报文来交流的，同时报文由HTTP协议进行规范。

一份报文包含报文头部和报文主体，报文头部里面多是HTTP协议里面用于通知客户端和服务端之间交流的规范。

而报文主体： 

对于请求报文的报文主体来说，会有客户端需要传给服务器的请求参数的数据。

而对于响应报文的报文主体来说，会有客户端需要服务器返回的数据。

然后，上述说到的数据就是实体，实体又可以细分为实体头部和实体主体，通常数据会存在于实体主体中，而实体头部可有可无，如果存在，那么实体头部中会有对实体主体内容的信息。

```js
报文: {
  报文头部（header）
  CR+LF换行
  报文主体（body）: {
    // 报文主体里面不就是请求报文中携带的请求参数数据和返回报文中返回的数据，然后在这里面也分头部和主体。
    实体头部? ： 实际信息的描述
    CR+LF换行
    实体主体： 传输的实际信息
    实体头部? 
    CR+LF换行
    实体主体
  }
}
```

从上可知： 

1、 实体级别是下属于报文主体的。

2、 实体由两部分组成。实体头部和实体主体。

3、 实体头部是可选的，不一定会带有。

4、 当实体头部不存在时，就是我们说的实体主体等同于报文主体。

5、 实体可以有0或多个。

_通用首部字段_

请求报文和响应报文都会使用的字段。

常见的首部通用字段：

| 字段名 | 说明 |
| ----- | ----------- |
| Cache-Control	| 控制缓存的行为，当使用缓存代理的时候，请求头和返回头都可以通过这个字段来控制缓存代理服务器的行为。 |
| Connection | 在1.1中默认值为keep-alive，默认使用持久化链接，减少客户端与服务器多次握手带来的性能消耗。 |
| Pragma | no-cache，作用同Cache-Control，告诉代理服务器不返回缓存的资源。此字段存在的意义是向后兼容，由于不能确保代理服务器使用的是HTTP 1.1，所以需要加这个字段，统一代理服务器的行为。 |
| Date | 创建报文时的日期时间 |

_请求首部字段_

从客户端发送到服务器的请求报文中使用的首部字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。

常见的首部请求字段：   

| 字段名 | 说明 |
| ----- | ----------- |
| Accept | 客户端告诉服务器我能支持的媒体类型及媒体类型的优先级。值如：text/html、image/jpeg |
| Accept-Encoding | 客户端告诉服务器我能支持的内容编码及内容编码的优先级 |
| Accept-Language | 客户端告诉服务器我能支持的语言及语言的优先级 |
| Authorization | 客户端告诉服务器的认证信息，让服务器去认证 |
| Proxy-Authorization | 客户端告诉代理服务器的认证信息，让代理服务器去认证 |
| Host | 因为存在在一台电脑（一个IP）下通过虚拟主机创建多个域名的情况，所以HTTP 1.1规定必须在首部传这个值来明确指出请求的主机名 |
| Referer | 告诉服务器我这个请求是从哪里（哪个URI）发过来的 |
| User-Agent | 此字段可包含创建请求的浏览器信息、用户代理名称、经过的代理服务器的名称等信息 |

_响应首部字段_

从服务器发送到客户端的响应报文中使用的首部字段，用于补充响应的附加信息、服务器信息、以及对客户端的附加要求等信息。

常见的首部请求字段：

| 字段名 | 说明 |
| ----- | ----------- |
| Server | 服务器告诉客户端我当前安装的HTTP服务器应用程序的信息 |
| ETag | 资源被缓存的时候，被分配的唯一性标识字符。类似于webpack里的hash值。对应唯一的一份资源 |
| Proxy-Authenticate | -- |
| WWW-Authenticate | -- |

_主体首部字段_

实体部分所使用的的首部字段，用于补充说明与实体相关的信息。

| 字段名 | 说明 |
| ----- | ----------- |
| Content-Type | 说明了报文主体内实体主体的媒体类型，和首部请求字段的Accept一样，是一对对应的值 |
| Content-Encoding | 说明了报文主体内实体主体的内容编码方式，和首部请求字段的Accept-Encoding一样，是一对对应的值 |
| Content-Language | 说明了报文主体内实体主体的语言类型，和首部请求字段的Accept-Language一样，是一对对应的值 |

_与Cookie相关的首部字段_

由于HTTP是无状态的，且HTTP 1.1中没有规范相关的用于管理用户登录状态的字段。由Netscape网景公司制定的规范。

| 字段名 | 说明 |
| ----- | ----------- |
| Set-Cookie | 由服务器生成并返回给客户端的一个用户身份的唯一标志符 |
| Cookie | 从服务器接收，客户端保存在本地并在之后的每一次请求中携带在请求头的一个用户身份的唯一标志符 |

_其他首部字段_

以上首部字段除了Cookie之外，都是HTTP 1.1协议规定的字段。但实际中，HTTP首部字段是可以自行扩展的。以下列出常用的几个：

| 字段名 | 说明 |
| ----- | ----------- |
| X-Frame-Options | 属于响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题 |
| X-XSS-Protection | 属于响应首部，用于控制浏览器XSS防护机制的开关 |
| p3p | 属于响应首部，通过利用p3p技术，让Web网站上的个人隐私变成一种 |

### HTTPS

HTTP有以下缺点：

1、对于客户端和服务器端来说，都无法确认对方（服务器端或客户端）是我想要连接的那一个。

2、客户端和服务器端交流的数据可能会被篡改，也就是中间者攻击。

这就是HTTPS诞生的原因。

_SSL_

Secure Socket Layer，安全套接层。是独立于HTTP的协议，是当今世界上应用最为广泛的网络安全技术。可以提供加密、证书认证和完整性保护。

_HTTPS_

HTTPS其实就是HTTP + SSL。通常情况下，HTTP是直接和TCP通信的。而HTTPS就是HTTP先和SSL通信，再由SSL和TCP通信。

即HTTP加上加密、证书认证和完整性保护之后就是HTTPS。

### 网络分层模型图

![网络分层模型](WangLuoFenCengMoXing.png "500px") 

![网络协议](XieYi.png "500px") 

### 数据包经过多层之后的结构

```js
帧: {
 Head // 链路层。包含数据包的一些说明项，比如发送者和接受者的MAC地址、数据类型等等
 Data: { 
   Head:  // 网络层IP、ARP。包括版本、长度、IP地址等信息
   Data: {  
     Head:  // 传输层TCP。定义了发出端口和接收端口
     Data: {
       Head:  // 应用层HTTP。定义了HTTP头部 
       body: { // 报文主体里面就是请求报文中携带的请求参数数据和返回报文中返回的数据，然后在这里面也分头部和主体。  
         实体头部? ： 实际信息的描述
         CR+LF换行
         实体主体： 传输的实际信息
         实体头部? 
         CR+LF换行
         实体主体
       }
     }
   }
 }
}
```

以上是网络上的数据包经过各层协议之后的数据结构。我们常用的能接触到的是HTTP协议部分。而每经过一层协议，都会包上一层外衣。

传输层TCP会带上端口等信息。

网络层IP会带上IP地址等信息。

链路层会带上MAC地址等信息。

我们都知道网络上的数据传输实际上就是从一个MAC地址传到另一个MAC地址。所以数据包的最外层携带的MAC地址信息将会被唯一的主机接收并解析数据包。

### 电脑能上网的原因

四个必要因素，在我们买到一个新电脑的时候，如果我们要连上网络，我们通常需要给新电脑设置四个参数。

> info

> Ipv4: 本机的IP地址。

> DNS: 域名解析服务的IP地址。

> 网关IP: 本地网络所属子网络的网关的IP地址。

> 子网掩码: 告诉我们本机的IP地址的哪部分是网络部分。IP地址为32位的地址，分为网络部分和主机部分，当两个IP地址的网络部分相同时，我们认为其处在同一子网络下。

### 网络层和链路层

```js
网络: {
 子网络1: {
  主机11: // 有唯一的MAC地址和IP地址。可能开着很多个应用程序，每个应用程序对应着一个端口。
  主机12: // 有唯一的MAC地址和IP地址。可能开着很多个应用程序，每个应用程序对应着一个端口。
  ...
 } 
 子网络2: {
  主机21: // 有唯一的MAC地址和IP地址。可能开着很多个应用程序，每个应用程序对应着一个端口。
  主机22: // 有唯一的MAC地址和IP地址。可能开着很多个应用程序，每个应用程序对应着一个端口。
  ...
 } 
 ... 
}
```

_IP地址与MAC地址_

MAC地址。Media Access Control Address，以太网地址，或称物理地址。用于在网络中唯一标识一个网卡。

`MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。`

IP地址。基于网络拓扑设计出的唯一的地址，相对于MAC地址是抽象的。

一台电脑只要不更换网卡，那么其MAC地址是一直不会变的，而IP地址是可以认为根据本地连接内的配置进行修改，虽然IP地址也是具有唯一性。

`一般情况下，IP地址作用于网络层，而MAC地址作用于链路层，两个地址之间的对应关系由ARP（地址解析协议）来完成。`

_IP_

IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。

`IP协议根据IP地址和子网掩码来判断任意两个IP地址是够处在同一个子网络。`

_ARP_

Address Resolution Protocol。ARP协议能够从IP地址得到MAC地址。

这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。

第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。

总之，有了ARP协议之后，我们就可以得到`同一个子网络内`的主机MAC地址，可以把数据包发送到任意一台主机之上了。

_端口_

同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？

也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

`每个应用程序对应着一个端口。`

_流程梳理_

`我可以把流程梳理一下，当我在主机11里使用微信和主机12的网友聊天的时候，发送了一句“你好”`

```js
注意这都是在本机内发生: {
  主机11会发出一份数据包（依据HTTP协议的请求报文，携带目标域名，也就是我们常说的URL），在报文主体的实体主体中携带上想要发送的信息“你好”。  // 应用层
  然后主机11会向其所属子网络下广播报文，目标IP为子网络下的DNS服务器IP地址。DNS服务器发现是发给自己的数据包，于是解析报文中的URL，得到并返回主机12IP地址。  // 应用层
  在获取到主机12IP地址之后，主机12IP地址与本机的IP地址分别和本机子网掩码做AND运算，查看主机12IP与本机IP是否处于同一个子网络下。
  然后数据包通过TCP协议进行数据压缩，并披上一层加入端口信息的外衣。   // 传输层
  然后数据包通过IP协议披上一层加入IP地址信息的外衣。    // 网络层
  然后主机11使用ARP协议向该子网络下的所有主机发送一个数据包，这个数据包中包含着主机12的IP地址。  // 网络层
  然后当前所有该子网络下的主机都会收到这份数据包，然而只有主机12发现这个数据包是给自己的，所以返回自己的MAC地址。  // 网络层
  就这样我们获取到了发送目标的MAC地址，即主机12的MAC地址。
  然后数据包披上一层加入MAC地址信息的外衣  // 链路层
}

最后这样的一个数据包会以广播的方式向该子网络下的所有主机发送，而其他的主机发现并不是给自己的，所以都不作处理。
只有主机12发现，哦，原来这是给我的，于是主机12获取到该数据包，并对该数据包逐层解析最后获取到目标端口号和数据。
然后发现目标端口号是微信程序在使用。
于是，主机12的微信中显示出“你好”。
```

`当我在主机11里使用微信和主机22的网友聊天的时候，发送了一句“你好”`

```js
注意这都是在本机内发生: {
  主机11会发出一份数据包（依据HTTP协议的请求报文，携带目标域名，也就是我们常说的URL），在报文主体的实体主体中携带上想要发送的信息“你好”。  // 应用层
  然后主机11会向其所属子网络下广播报文，目标IP为子网络下的DNS服务器IP地址。DNS服务器发现是发给自己的数据包，于是解析报文中的URL，得到并返回主机22IP地址。  // 应用层
  在获取到主机22IP地址之后，主机22IP地址与本机的IP地址分别和本机子网掩码做AND运算，发现主机22IP与本机IP不处于同一个子网络下。
  然后数据包通过TCP协议进行数据压缩，并披上一层加入端口信息的外衣。   // 传输层
  然后数据包通过IP协议披上一层加入IP地址信息的外衣。    // 网络层
  然后主机11使用ARP协议向该子网络下的所有主机发送一个数据包，这个数据包中包含着主机11的默认网关1的IP地址。  // 网络层
  然后当前所有该子网络下的主机都会收到这份数据包，然而只有默认网关1发现这个数据包是给自己的，所以返回自己的MAC地址。  // 网络层
  就这样我们获取到了默认网关1的MAC地址。
  然后数据包披上一层加入MAC地址信息的外衣，数据包包含主机11和默认网关1的MAC地址信息  // 链路层
}

然后这样的一个数据包会以广播的方式向该子网络下的所有主机发送，而其他的主机发现并不是给自己的，所以都不作处理。
只有主机11所处的子网络的默认网关1发现，哦，原来这是给我的，于是默认网关1获取到该数据包，提取信息并将数据包转给主机22所处子网络的默认网关2。
默认网关2再将数据包派发给主机22。
然后发现目标端口号是微信程序在使用。
于是，主机22的微信中显示出“你好”。
```

`唯一的区别就是两个主机不在同一个子网络下。而ARP协议是作用在同一个子网络下的。所以只能把数据包传送到两个子网络连接处的"网关"（gateway），让网关去处理。其余步骤相同。`

### 正向代理与反向代理

正向代理隐藏真实客户端，反向代理隐藏真实服务端

正向代理就是客户端通过一个代理服务器访问真正的服务器，这一个过程中真正的服务器并不知道是哪个客户端发送的请求，只知道是代理服务器发送的请求。所以在服务器这边就隐藏了真实客户端。

反向代理就是以代理服务器来接收客户端的请求，然后将相应的请求通过映射发给真实的服务器，这一过程中客户端所认为的真实客户端是代理服务器，然后代理服务器通过映射找到的服务器才是真正提供数据的服务器。所以在客户端这边就隐藏了真实服务端。

![代理](DaiLi.png "500px") 
 
_正向代理_
 
如图所示，正向代理的时候，在客户端这边是明确自己没有权限访问服务端，但是有权限访问一个代理服务器，而这个代理服务能访问我们想要访问的服务端。于是我们先连上代理服务器，让代理服务器去访问服务端，服务端返回数据给代理服务器，再由代理服务器返回给客户端。这就是正向代理的流程。
 
`可以知道，客户端是与代理服务器有联系的，是互相“认识”的。`通常我们需要设置正确的代理服务器IP地址和代理程序的端口。对服务端来说，直接接触的是代理服务器，所以服务端并不能知道是哪个客户端发送的请求。

正向代理的用途：

1、 访问原来无法访问的资源，如google。即我们所用的SS、SSR等翻墙软件都是用到了正向代理服务器。

2、 以做缓存，加速访问资源。缓存代理。
 
3、 对客户端访问授权，上网进行认证。

4、 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息。
 
_反向代理_

反向代理就是代理服务器早就配置好了相应的映射到具体的服务端（一对多）。而客户端这边以为自己访问的是服务端，实际上访问的是代理服务器，通过代理服务器映射到真正的服务端返回数据。所以这样对客户端来说就是隐藏了真正的服务端。

反向代理的用途：

1、 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击

2、 负载均衡，通过反向代理服务器来优化网站的负载

### 端口映射

端口映射，其实就是常说的网络地址转换（Network Address Translation，NAT）地址转换的一种，其功能就是把在公网的地址转翻译成私有地址。

个人理解：当我们用外网访问公司内网的时候，是无法直接访问的，需要我们进行一些配置。当我们在外网向内网服务器发送一个请求的过程。

首先会经过DNS服务器进行域名解析，然后得到目标IP。目标IP匹配到公司的路由器，于是公司的路由器会接收到请求数据包。通常我们会在路由器上做端口映射，映射到公司内部的nginx代理服务器。

在nginx代理服务器上又会通过反向代理到真正响应并返回数据的服务器，并依原路返回数据。

这就是在外网访问内网时的一个完整的步骤。其中关键在于路由器上的端口映射和nginx上的反向代理服务。

[内网和外网之间的通信](https://www.cnblogs.com/ranyonsue/p/9713992.html)

### 其他术语

_Web应用_

通过Web功能提供的应用程序。比如购物网站、网上银行、SNS（社交网络服务）等等。

### 参考资料

[五层协议介绍](https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)

[一次请求的例子](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)

export const httpMeta = {
  anchors: [
    '基本知识',
    'URI与URL',
    'HTTP',
    '代理和网关',
    'HTTP 1.1首部字段',
    'HTTPS',
    '网络分层模型图',
    '数据包经过多层之后的结构',
    '电脑能上网的原因',
    '网络层和链路层',
    '其他术语',
    '正向代理与反向代理',
    '参考资料',
  ]
}










