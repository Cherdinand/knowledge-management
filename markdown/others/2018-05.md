import location from 'markdown/images/location.png';

### Legion系列理解
``` js
const app = create();
app.start() => ReactDOM.render() // Provider store = new StoreManage
storeManage = {
    history,
    initialState,
    states,
    prototype: {
        mount(){},
        unmount(){},
        getInitialState(){},
        getState(){},
        getType(){},
        initState(){},
        registerEventScopes(){},
        unregisterEventScopes(){},
        checkStoreClass(){},
    }
}
```
每个单页应用的启动都会将创建storeManage实例(在app.start中创建)，然后将storeManage实例作为props传入Provider组件

mobx-react提供的Provider组件内部使用了context，而storeManage实例将以
``` js
{
    mobxStores: storeManage
}
```
的形式以context的形式给到子组件使用。

// storeClass1,storeClass2,... , storeClass n ,组件使用到的store类

然后通过legion-store-react提供的@connect(storeClass1,storeClass2,... , storeClass n,storeToProps)连接store和React

@connect会遍历组件注入的storeClass，然后从storeManage获取到每个storeClass对应的storeClass实例 (todo  @createInstance  创建实例的过程)，
将（每个storeClass实例 + react-router赋予的props + context）作为参数调用storeToProps，storeToProps => return props;

然后会做一个类似于Object.assign的操作，将react-router等赋予的props和storeToProps所return的props合并后通过React.createElemnt()
将props传给组件(这个组件就是我们写的业务组件，或者说被connect的组件)。


_connect_

@connect(storeClass,storeToProps)
storeClass 可以注入多个storeClass，内部通过...args以数组的形式获取
storeToProps ==>>>> ([storeClassInstance],history,match,location,context) => {}

_createInstance 创建实例的过程_

某次路由变化加载经过connect的组件的时候，@connect会遍历组件注入的storeClass，然后调取storeManage.getState(storeClass,true)来获取到storeClassInstance。
如果是初次加载此组件，也就是初次注入此组件的storeClass，此时会先存储storeManage.types，然后实例化storeClass生成storeClassInstance，并存储在storeClass对应
生命周期的具体实例的states中，方便下次渲染这个组件的时候直接从内存中获取storeClassInstance。最终返回这个storeClassInstance。
如果非初次加载此组件，那么会直接返回之前保存在具体实例中的storeClassInstance。
注意，除非切换单页应用，否则当前单页应用的state会一直保存在内存中。

_storeManage解析_
``` js
storeManage: {
    types: {  // todo 没发现这个types属性有什么作用
        namespace: {
            storeClassName: storeClass,
            ...
        }
        ...
    },

    states: {  => new LifecycleStateManage() // LifecycleStateManage实例用于代理分发，根据注入的storeClass的meta.lifecycle来决定用哪个具体实例进行操作
        states: [
            Application => new StateManage() : {  // 每个具体操作的实例
                states: {
                    namespace: {
                        storeClassName: storeClassInstance
                        ...
                    }
                    ...
                }
                prototype: {  // 提供了对states进行注入和获取的操作
                    get(storeClass){},
                    set(storeClass,storeClassInstance){},
                }
            }
            History => new HistoryStateManage(),
            Location => new LocationStateManage(),
        ]
    },
    prototype: { // storeManage提供api接口，让外界能够对store进行初始化，注入，获取等操作
        initState(){},
        getState(){}
    }
}
```

storeManage是提供了一个states属性和一些store管理相关方法(如store初始化，获取store实例等)的类。其主要功能是提供api接口，让被connect进去的storeClass能够被注入到state中，然而注意这只是个接口，并未真正做事。

而其states属性是LifecycleStateManage的实例，这个实例也有个states属性，包含storeClass的三种生命周期，每个生命周期都是具体的实例，其结构如下：
``` js
states： [
    Application => new StateManage()
    History => new HistoryStateManage()
    Loaction => new LoactionStateManage()
]
```

这样一看，LifecycleStateManage就是个代理分发的作用，根据connect进来的storeClass的meta.Lifecycle的值来决定要存储在哪个stateManage中。

而每个生命周期的实例StateManage，HistoryStateManage，LoactionStateManage，才是真正存储store的容器，每个生命周期的实例也都会有一个states属性。用来存储单页应用的state。其结构如下：
``` js
states： {
    namespace： {
        storeClassName: storeClassInstance,
        ...
    }
    ...
}
```

_namespace_

每个单页应用层面有一个namespace，在storeManage里面会用到。

每个单页应用中可能会引用到e-widget的组件或者其他单页应用中处于common文件夹下的组件，而这些组件也会绑定store，e-widget的namespace统一为widget。

所以namespace可以区分不同单页应用之间的重名storeClassName。

同时，由上面的说法来看，项目中的store确实都是每个组件mount的时候注入的，子组件可以从connect的父组件通过props传值也可以自身也connect。

_meta.contextTypes_

用于从当前storeClass引入别的storeClass，达到可跨storeClass的作用

在初始化storeClassInstance实例之前会创建一个storeContext实例，里面会根据storeClass的meta.contextTypes属性，生成如下的实例：
``` js
StoreContextInstance = {
    _manage => storeManage,
    _type => storeClass,
    // 如果有定义contextTypes,contextTypes[key1]必须为storeClass，意思是我这类storeClass要引用例外一个storeClass里的东西
    key1: {
        get: ()=> {
            return this._manage.getState(contextTypes[key1], true); // 获取到另外一个storeClassInstance
        },
        set(){},
    },
    key2,
    ...
}
```

然后会在创建当前storeClassInstance的时候将这个StoreContextInstance作为参数传给当前storeClass，这样在当前storeClass的constructor里面就可以操作通过StoreContextInstance.key1其他storeClassInstance。还可以引入多个其他storeClassInstance。

_router_

多页应用中每个单页应用的路由由服务器配置映射，服务器根据路由匹配到对应的打包好的前端提供的单页应用包（一般每个单页应用包分一个文件夹）。

每个单页应用内部不同模块跳转之间的路由由react-router 4.0完成。


### 单页应用工作原理

单页面应用程序（SPA）是一个网站，它根据导航操作（例如，单击链接）重新呈现其内容，而不向服务器请求获取新的HTML。

<img src={location} alt="location" title="location拆解图"/>

### 如何在微信公众号打开本地微信页面

`前提：微信页面只能用域名打开。如：tste.360kad.com`

通常，为了记忆方便，我们把IP变成一个个的域名来输入到浏览器进行访问。而这使得访问网站时要先将其域名解析为IP。

DNS(domain name server)就是将域名解析为IP的。在进行DNS请求之前，系统会先检查本地Hosts文件是否有地址映射关系，有则调用这个地址映射，无则请求DNS。

然后，我们开发的时候正常情况可以用localhost:port来打开本地代码文件。

但是，由于微信页面只能用域名打开的原因，而我们又想打开本地文件，所以我们必须要在Hosts文件将此域名映射到本地ip或者127.0.0.1。这样当我们访问tste.360kad.com域名的时候，会映射到本地127.0.0.1，从而获取本地文件。如果没有配置Hosts文件，就会进行DNS请求去请求外网上已经注册的域名，在我们公司内部上就是会去访问测试环境的包。

同时，公司的微信项目还需要proxy代理，将接口请求代理到具有接口api的server。

### package.json的版本描述语法
波浪号（tilde）+指定版本：比如~1.2.2，`表示安装1.2.x的最新版本（不低于1.2.2）`，但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。

插入号（caret）+指定版本：比如ˆ1.2.2，`表示安装1.x.x的最新版本（不低于1.2.2）`，但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。

```js
~1.1.1      >=1.1.1 <1.2.0
~1.1        >=1.1.0 <1.2.0
~1          >=1.0.0 <2.0.0
^1.1.1      >=1.1.1 <2.0.0
^0.1.1      >=0.1.1 <0.2.0 注意这里,不要以为是 0.1.1-1.0.0 之间
^0.0.1      >=0.0.1 <0.0.2 同上,请注意
```

export const _201805Meta = {
  anchors: [
    'Legion系列理解',
    '单页应用工作原理',
    '如何在微信公众号打开本地微信页面',
    'package.json的版本描述语法',
  ]
}