### JavaScript

解释型语言： 每一次执行代码的时候都需要先经过解释，然后才能执行。 （Python等）

编译型语言： 经过一次编译之后，以后执行代码都不需要再编译代码。 （C、C++等）

`JavaScript是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。`

``` js
ng      babel或typescript转译为es5                      V8引擎
react  ------------------------------------------> es5代码  -----------------> 浏览器可以识别并执行的代码
vue
```

在代码的转译过程中，都会使用到AST（抽象语法树）。这是一个表示语法结构的对象。

### 底层工具

1. 引擎：负责从始至终的编译和执行我们的 JavaScript 程序。
1. 编译器：引擎 的朋友之一；处理所有的解析和代码生成的重活儿。
1. 作用域：引擎 的另一个朋友；收集并维护一张所有被声明的变量的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。

### LHS与RHS

当我们使用到一个变量的时候，我们需要在作用域中对变量进行查询。那么查询的方式就分为LHS和RHS两种。

通常认为RHS的查询方式只是为了找到变量所存的值。

而LHS的查询方式在意的则是变量本身是否存在，对变量所存的确切的值无所谓。

``` js
const a = function(s){
  const b = s;
  console.log(b)
}

a(2) 
```

以上'const a = ' 的变量a就是LHS，我们只在意能否在作用域中找到变量a，然后给他赋值为函数，并不在乎它的值是什么。

而后在'a(2)' 调用函数a的时候，有一个变量赋值 's = 2' 这同样也是一个LHS。

然后在'const b = s'这一句中， 右边的 '= s'则是RHS，我们需要在作用域中找到变量s并获取到变量s存的值。 左边的 'const b = '则是LHS。

最后 'copnsole.log(b)' 则是RHS，在作用域中获取到变量b存的值。

### ReferenceError与TypeError

`ReferenceError 是关于 作用域 解析失败的，而 TypeError 暗示着 作用域 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。`

如果在进行RHS查询的时候，找到了全局作用域都还没找到变量的话，那么引擎会抛出一个ReferenceError。

如果在进行LHS查询的时候，找到了全局作用域都还没找到变量的话。在非严格模式下，LHS查询会在全局作用域中创建一个同名的新变量。而在严格模式下，就不会在全局作用域中创建一个同名的新变量，也就是找不到变量，所以也会抛出一个ReferenceError。`这是因为在严格模式下不允许自动/隐含的全局变量创建。`

``` js
function foo(a) {
	console.log( a + b ); // 'a + b'中使用RHS在作用域中查询变量b的时候，找到了全局作用域也找不到变量b，这时会抛出ReferenceError
	b = a;  // 由于前一句报错， 所以这句并不会运行。奇怪的点是这样在foo作用域中并没有变量b的提前声明。
}

foo( 2 );
```

``` js
function foo(a) {
	console.log( a + b ); // 'a + b'中使用RHS在作用域中查询变量b的时候，在foo作用域中找到了变量b，但是由于还没赋值，所以值是undefined
	var b = a;  // 这样就会在foo作用域中有提前声明，但是还没赋值。
}

foo( 2 );
```

``` js
function foo(a) {
	b = a;  // b在执行LHS查询时直到全局作用域都没有发现变量b，于是在全局作用域中创建了变量b并把a的值赋给变量b
}

foo( 2 );

console.log(b)  // 2  于是在全局作用域中能访问到变量b的值为2
```

``` js
function foo(a) {
	var b = a;  // 在foo作用域中声明并创建新变量b，然后使用LHS查询到变量b，并将a的值赋给b。
}

foo( 2 );

console.log(b)  // ReferenceError 在全局作用域中找不到变量b
```

### 作用域

作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用。

LHS 和 RHS 引用查询都从当前执行中的 作用域 开始，如果有需要（也就是，它们在这里没能找到它们要找的东西），它们会在嵌套的 作用域 中一路向上，一次一个作用域（层）地查找这个标识符，直到它们到达全局作用域（顶层）并停止，既可能找到也可能没找到。

`未被满足的 RHS 引用会导致 ReferenceError 被抛出。未被满足的 LHS 引用会导致一个自动的，隐含地创建的同名全局变量（非Strict模式），或者一个 ReferenceError（Strict模式）。`

### 词法作用域

JavaScript中使用的作用域模型是词法作用域。

`词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。`编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。

### 闭包

`闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。`

### 作用域与this的类比

在编程语言中作用域分为词法作用域和动态作用域两种模型。

`当然在JavaScript中使用的是词法作用域模型。`也就是一个变量所处的作用域是在编写代码的时候变量所处的位置决定的。

`而在动态作用域中一个变量所处的作用域是由变量被使用的位置决定的。`

``` js
var c = 3;

function a(){
  console.log(c)
}

function b(){
  var c = 4;
  a()  // 词法作用域： 3； 动态作用域： 4；
}
```

上述例子中，如果是按照JavaScript中的词法作用域的话，函数a在b中被调用，但是依据词法作用域是在编写的时候决定的，所以在函数a作用域中使用RHS没找到变量c之后，便会带全局作用域中查询变量c，于是会打印出3，而不是4。

但是如果是按照动态作用域来的话，函数a在b中被调用，于是函数b作用域则成为了函数a作用域的上一层作用域，当使用RHS在函数a作用域中没找到变量c的时候，便来到了上一层也就是函数b作用域中查询变量c，发现值为4，于是打印出4。

这就是词法作用域与动态作用域的区别。

`而this的机制在很大程度上与这个有点类似，所以在此作一个类比。`

`this的机制更类似于动态作用域，也就是this指向被调用的对象。`谁调用了我，我就指向谁。而不是我编写在哪个对象内，我就指向这个对象。`也就是说this 不是编写时绑定，而是运行时绑定。`

然而，在es6中的箭头函数，就可以将this的绑定机制回到类似于词法作用域的机制。`当使用箭头函数的时候，箭头函数中的this从自己的作用域链的上一层继承this。`

``` js
const name = 'chenkang';

const a = {
  name: 'xinxin',
  getName: () => {
    return this.name
  }
}

console.log(a.getName()) // chenkang 当getName函数使用了箭头函数之后，getName函数中的this指向了上一层作用域在这里也就是window，所以尽管是被对象a调用的，this.name还是指向了window.name，而不是a.name。
```

### 判定this的优先级

函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。

var bar = new foo()

函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。

var bar = foo.call( obj2 )

函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。

var bar = obj1.foo()

否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。

var bar = foo()

export const ScopeAndThisMeta = {
  anchors: [
    'JavaScript',
    '底层工具',
    'LHS与RHS',
    'ReferenceError与TypeError',
    '作用域',
    '词法作用域',
    '闭包',
    '作用域与this的类比',
    '判定this的优先级',
  ]
}
