React 渲染性能优化的三个方向，其实也适用于其他软件开发领域。

1. 减少计算量。  => 对应到react中就是 `减少渲染的节点` 或者 `降低组件渲染的复杂度`
1. 利用缓存。  => 对应到react中就是 `避免重新渲染，利用函数式编程的memo方式来避免组件重新渲染`
1. 精确重新计算的范围。  => 对应到react中就是 `绑定组件和状态关系，精确判断更新的时机和范围，只重新渲染脏的组件，或者说降低渲染范围`

### 减少渲染的节点/降低组件渲染的复杂度

首先从计算的量上下功夫，减少节点渲染的数量或者降低渲染的计算量可以显著的提高组件渲染性能。

1. 不要在渲染函数都进行不必要的计算
1. 减少不必要的嵌套
1. 虚拟列表
1. 惰性渲染
1. 选择合适的样式方案

__不要在渲染函数都进行不必要的计算__

不要在渲染函数(render)中进行数组排序、数据转换、订阅事件、创建事件处理器等等。`渲染函数中不应该放置太多副作用`。

__减少不必要的嵌套__

1. 使用React新特性 Fragment 组件代替不必要的层级嵌套。
1. 拥抱React Hooks代替 高阶组件/RenderProps 进行逻辑复用。

__虚拟列表__

虚拟列表是常见的‘长列表'和'复杂组件树'优化方式，它优化的本质就是减少渲染的节点。`虚拟列表只渲染当前视口可见元素。`

虚拟列表常用于以下组件场景:

1. 无限滚动列表，grid, 表格，下拉列表，spreadsheets
1. 无限切换的日历或轮播图
1. 大数据量或无限嵌套的树
1. 聊天窗，数据流(feed), 时间轴

相关组件方案:

1. react-virtualized
1. react-window

__懒加载__

`懒加载初衷本质上和虚表一样，也就是说我们只在必要时才去渲染对应的节点。`

举个典型的例子，我们常用 Tab 组件，我们没有必要一开始就将所有 Tab 的 panel 都渲染出来，而是等到该 Tab 被激活时才去惰性渲染。

还有很多场景会用到惰性渲染，例如树形选择器，模态弹窗，下拉列表，折叠组件等等。

__选择合适的样式方案__

 ![Css渲染性能对比](CssPerformance.jpg "500px") 

样式运行时性能方面大概可以总结为：`CSS > 大部分CSS-in-js > inline style`

### 避免重新渲染

1. 减少内联对象和内联函数的使用
1. 给基础UI组件添加浅比较
1. 给对象数据进行缓存
1. 简化 state

__减少内联对象和内联函数的使用__

``` js
<div onClick={() => console.log('trigger re-render')} />
<div style={{color: 'red'}} />
<div data={{name: 'cherdinand'}} />
```

上面例子中给的本质上都是内联对象作为props的情况，这种props在传递的时候，即使数据本身没有发生变化，也会生成一个新的对象，从而使react认为需要重新渲染，所以应该避免这种写法。

__给基础UI组件添加浅比较__

对于粒度最小的UI组件添加shouldComponentUpdate生命周期钩子函数，或者直接类继承React.PureComponent，当组件为函数组件的时候，可以用React.memo包裹函数组件。这三个方法都是在组件内部实现了shouldComponentUpdate 生命周期内的浅对比，避免重新渲染。

__给对象数据进行缓存__

像我们在减少内联对象和内联函数的使用中提到的。由于对象的特殊性，导致即使对象数据是相同的，react也会认为对象发生了变化。这时我们可以给对象数据作缓存，如果对象数据没有发生变化，那么就给它缓存起来。

`我们可以使用React Hooks里内置的 useMemo 和 useCallback 来缓存对象数据和回调函数。`

__给对象数据进行缓存__

不是所有状态都应该放在组件的 state 中. 例如缓存数据。按照我的原则是：`如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.`

### 精细化渲染
1. 响应式数据的精细化渲染
1. 不要滥用 Context



export const PerformanceOptimizationMeta = {
  anchors: [
    '减少渲染的节点/降低组件渲染的复杂度',
    '避免重新渲染',
    '精细化渲染',
  ]
}