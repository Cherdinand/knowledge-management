### 假设

React 在比较新旧 2 棵虚拟 DOM 树的时候，为了控制时间复杂度（将 O(n3) 控制到  O(n) ），提出了两个假设： 

1.如果 2 个节点的类型不一样，以这 2 个节点为根结点的树会完全不同。（`一棒子打死，只要爸爸节点类型不同，子孙全部认为是不同的，这条策略极大的减少了时间复杂度`）

2.对于多次 render 中结构保持不变的节点，开发者会用一个 key 属性标识出来，以便重用

### diff算法

对于不同类型的元素节点（div、p），该元素节点及其子孙节点全部unmount并重建tree插入到DOM中。
对于相同类型的元素节点（div、p），对比该元素节点的属性，只更改改变的属性,触发重渲染，不会经历unmount阶段。

对于不同类型的组件节点（自定义组件），通常认为不同的组件不会存在相似的tree结构，所以也是直接删除组件tree，并创建新的组件tree，同时组件所属的state也会清除。
对于相同类型的组件节点（自定义组件），由props的改变触发组件重渲染。

对于兄弟节点之间（这里的兄弟节点指的是相同类型的兄弟节点，因为如果类型不同是直接进行删除并重建操作的）的增加，删除，移动操作导致的tree变化，通常我们会给这种元素列表中的每一个元素添加独一无二的key。React的diff算法在对比前后两次虚拟DOM快照的时候，如果发现前后处于不同位置的元素的key值是相同的，则只是对元素进行移动。而如果发现新的key值，则重新创建元素。

移动规则如下： 

```js
// 移动的原则是将原来的元素往右边移

前元素列表： [A, B, C, D]
后元素列表： [B, A, D, C]

react会将元素在前元素列表和后元素列表中的index值进行比较，让我们简单的理解为preIndex和nextIndex。如果preIndex < nextIndex，则进行右移，反之不动。

所以，对于B，preindex为1，nextIndex为0。preIndex > nextIndex，不动。
所以，对于A，preindex为0，nextIndex为1。preIndex < nextIndex，右移。
```

### key的妙用

可以注意到在React的diff算法中，`key值一旦发生变化，则整个元素或组件会被删除并重建（mount）`，那么在那些需要在DidMount中调取接口获取数据来显示的组件，我们可以通过修改key值来达到`刷新页面`的操作。


### 相关文章

[diff算法源码详解](https://segmentfault.com/a/1190000017039293)

export const DiffMeta = {
  anchors: [
    'diff算法',
    'key的妙用',
    '相关文章',
  ]
}